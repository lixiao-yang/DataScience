;type your name after the colon:

#lang racket
(require rackunit)
(require rackunit/text-ui)

#|
CS 270
Homework 5
Professor B. Char, M. Boady,  J. Johnson, G. Long, and S. Earth

Tests given are not designed to be comprehensive.
They will give you an idea if your code is right, but they do not test all possible cases.
Think about your design.  When grading, we may add additional tests for your functions.

- make sure the entire file is accepted by DrRacket. If you don't finish some problems, comment out any
unfinished code so that it doesn't throw errors.

Submit this HW8 racketfile into Gradescope

Important Rules:
0) All function names are given, do not change the names or signatures of any functions.
1) If the instructions state something must be recursive, you will receive a zero if it is not recursive.
   Helper functions are sometimes allowed (and then the recursion could be in the helper rather than main).
2) If you think you need functions not taught in class, you are likely approaching the problem wrong
3) while you make cond cases to handle bases, it is not permitted to simply write
   cond cases for all the unit tests!
4) When you start, most unit tests will be failing. Once you implement the required functions, the unit
   tests associated with those functions should pass. Do not modify the tests unless indicated.


Each of the below questions has two parts.
First, you will be asked to write a Racket function to solve a problem (except in the very first problem,
in which the implementation will be provided for you). 
Secondly, you will be asked to prove by induction with equational reaasoning that your Racket
code is correct by exhibiting the stated property.
IMPORTANT:  since we haven't learned how to do equational reasoning with advanced racket functions (such as
append, length, foldr, map, cond etc), you should not use those in your implementations.
Also, if you think you need helpers or nested-ifs, then you are probably making the code (and hence the proof)
more complicated than necessary.  All functions in this homework should be recursive.
|#

; Question 1 [10 pts total]:
; input contract = L is a list of Boolean constants
; output contract = (myst L) is equivalent to the proposition stating "L has ____________________"
 
(define/contract (myst L)
     (-> (listof boolean?) boolean?)
     (if (null? L) #t (equal? (first L) (myst (rest L)))))
;end

#| part 1a [2 pts]: list below all contractually legal inputs L such that
                    (or (null? (rest (rest L))) (null? (rest (rest (rest L)))))
1. (#t #t)
2. (#t #f)
3. (#f #t)
4. (#f #f)
5. (#t #t #t)
6. (#t #t #f)
7. (#t #f #t)
8. (#f #t #t)
9. (#t #f #f)
10. (#f #t #f)
11. (#f #f #t)
12. (#f #f #f)

  part 1b [1 pts]: evaluate the function myst on all of inputs in the previous part and record the results below by
  replacing all the nulls in the unit tests below with your answers to part 1a, and replace all the 0s with
  the actual result.  (if done correctly, you should end up with exactly twelve distinct unit tests)
|#
(display "Question 1 myst Tests\n")
(define-test-suite test_myst
  (test-equal? "" (myst '(#t #t)) #t)
  (test-equal? "" (myst '(#t #f)) #f)
  (test-equal? "" (myst '(#f #t)) #f)
  (test-equal? "" (myst '(#f #f)) #t)
  (test-equal? "" (myst '(#t #t #t)) #t)
  (test-equal? "" (myst '(#t #t #f)) #f)
  (test-equal? "" (myst '(#t #f #t)) #f)
  (test-equal? "" (myst '(#f #t #t)) #f)
  (test-equal? "" (myst '(#t #f #f)) #t)
  (test-equal? "" (myst '(#f #t #f)) #t)
  (test-equal? "" (myst '(#f #f #t)) #t)
  (test-equal? "" (myst '(#f #f #f)) #f))
(define q1b_score (- 12 (run-tests test_myst 'verbose)))

#| part 1c [2 pts]: Fill in the blank in the output contract by conjecturing a result based on your examples.  
  Note that your stated contract should hold for *all* possible legal inputs L (make more tests if need be).
  your answer here must be correct in order to get any credit for the next part, so you may wish to check your
  conjecture with a TA or the instructor.  Hint: what do all the #t results have in common vs the #f results?

L has odd number of #f


 part 1d [5 pts]: Prove the correctness of the provided implementation.
 In other words, use structural induction to prove the output contract is always met.
 Hint: there will end up being four different cases you need to consider. (Take a peek ahead at Question 3b if
 you are not certain the best way to structure this argument)

Base case: anchored at n = 0

LHS:
1. (myst null)                                              Premise
2. (if (null? null) #t (equal? (first L) (myst (rest L))))  Apply def. of myst
3. (if #t #t (equal? (first L) (myst (rest L))))            Evaluate null?
4. #t                                                       Evaluate if

RHS: If the list is empty, "L havs odd number of #f" is true.

Since LHS=RHS, the base case has been established.

IH: For all possible legal input L, (myst L)=M, where M is equivalent to the proposition stating "L has odd number of #f"

LHS:
1. (myst (cons a L)                                                                    Premise
2. (if (null? (cons a L)) #t (equal? (first (cons a L)) (myst (rest (cons a L)))))     Apply def. of myst
3. (if #f #t (equal? (first (cons a L)) (myst (rest (cons a L)))))                     Evaluate null?
4. (equal? (first (cons a L)) (myst (rest (cons a L))))                                Evaluate if
5. (equal? a (myst (rest (cons a L))))                                                 Evaluate first-cons
6. (equal? a (myst L))                                                                 Evaluate rest-cons
7. (equal? a M)                                                                        By IH

Leap:
(L is not a null list and E is a list with an even number of #f and D is a list with an odd number of #f)
1) (cons #t E), a=#t, L contains even number of #f. (equal? a M)=#f
2) (cons #f E), a=#f, L contains even number of #f. (equal? a M)=#t 
3) (cons #t D), a=#t, L contains odd number of #f. (equal? a M)=#t
4) (cons #f D), a=#f, L contains odd number of #f. (equal? a M)=#f

Thus both the base case and the leap have been demonstrated and consequently it has now
been proved by induction that (myst L) is equivalent to the proposition stating
"L has odd number of #f". 


|#
; Question 2: (5 points)
; Write a recursive function satisifying the following specifications
; Input contract:  n is a nonnegative integer
; Output contract: (cubesum n) is the sum of the first n perfect cubes
; note: it is overkill to use the expt function here.
; Example:  (cubesum 4) would be 100 because of 1 + 8 + 27 + 64

(define (cubesum n)
  (if (zero? n) 0
      (+ (* n n n) (cubesum (- n 1)))));Implement Me


;Test Bed
(display "Question 2 cubesum Tests\n")
(define-test-suite test_spec_sum
  (test-equal? "" (cubesum 2) 9)
  (test-equal? "" (cubesum 5) 225)
  (test-equal? "" (cubesum 7) 784)
  (test-equal? "" (cubesum 9) 2025)
  (test-equal? "" (cubesum 10) 3025))
(define q2a_score (- 5 (run-tests test_spec_sum 'verbose)))

#| Question 2b (5 points)
Prove by induction that for all nonnegative integers, (cubesum n) = (n^2)*(n+1)^2 /4
Enter your proof below:

Base case: anchored at n=0
LHS:
1. (cubesum 0)                                      LHS of base case, anchored at n=0
2. (if (zero? 0) 0 (+ (* 0 0 0) (cubesum (- 0 1)))) Apply def. of cubesum
3. (if #t 0 (+ (* 0 0 0) (cubesum (- 0 1))))        Evaluate zero?
4. 0                                                Evaluate if

RHS: (0^2)*(0+1)^2/4=0
Since LHS=RHS, theorem holds for the base case.

IH: (cubesum k)=(k^2)*(k+1)^2 /4

LHS:
1. (cubesum (+ k 1))                                    LHS anchored at n=k+1
2. (if (zero? (+ k 1)) 0 (+ (* (+ k 1) (+ k 1) (+ k 1)) (cubesum (- (+ k 1) 1)))) Apply def. of cubesum
3. (if #f 0 (+ (* (+ k 1) (+ k 1) (+ k 1)) (cubesum (- (+ k 1) 1)))) Evaluate zero?
4. (+ (* (+ k 1) (+ k 1) (+ k 1)) (cubesum (- (+ k 1) 1))) Evaluate if
5. (+ (* (+ k 1) (+ k 1) (+ k 1)) (cubesum k))          Evaluate + and -
6. (k+1)^3 + (k^2)*(k+1)^2/4                            Invoke IH
7. (k^2+4k+4)*(k+1)^2/4                                 Algebra
8. ((k+1)^2)*(k+2)^2/4                                    Algebra

RHS(n=k+1): ((k+1)^2)*(k+2)^2/4
Since LHS=RHS, we know the theorem is true.

Consequently, since we demonstrated both the base case and the leap step, then
by the principle of racket induction the theorem holds for all inputs.


|#

; Question 3: (5 points)
; Write a recursive function satisifying the following specifications
; Input:  L is a (possibly empty) list of integers.
; Output: (evenOnes L) is a boolean value which is true iff the quantity of ones in L is an even amount
(define (evenOnes L)
  (if (null? L) #t (xor (equal? 1 (first L)) (evenOnes (rest L)))));Implement Me


;Test Bed
(display "Question 3 evenOnes Tests\n")
(define-test-suite test_evenOnes
  (test-equal? "" (evenOnes '(2)) #t)
  (test-equal? "" (evenOnes '(1)) #f)
  (test-equal? "" (evenOnes '(1 1)) #t)
  (test-equal? "" (evenOnes '(7 1)) #f)
  (test-equal? "" (evenOnes '(2 -1)) #t)
  (test-equal? "" (evenOnes '(1 1 2)) #t)
  (test-equal? "" (evenOnes '(4 1 2)) #f)
  (test-equal? "" (evenOnes '(2 8 1)) #f)
  (test-equal? "" (evenOnes '(1 22 1 -9)) #t)
  (test-equal? "" (evenOnes '(1 22 1 -9 1)) #f))
(define q3a_score (- 10 (run-tests test_evenOnes 'verbose)))

#|
Question 3b (5 points)
Prove by induction, algebra, and equational reasoning that
If L contains an even number of ones then (evenOnes L) = #t (i.e. "L contains an even amt of ones" is a True sentence)
If L contains an odd number of ones then  (evenOnes L) = #f (i.e. "L contains an even amt of ones" is a False sentence)
Hint for the Leap: you need 4 cases (cons 1 E), (cons x E), (cons 1 D), (cons x D)
Where, x!=1, E is a list with an even number of ones and D is a list with an odd number of ones.
Enter your proof below:

Base case: 
LHSï¼š
1. (evenOnes null)                           Premise
2. (if (null? null) #t (xor (equal? 1 (first null)) (evenOnes (rest null)))) Apply def. of evenOnes
3. (if #t #t (xor (equal? 1 (first null)) (evenOnes (rest null)))) Evaluate null?
4. #t                                        Evaluate if

RHS: An empty list contains zero ones, which is even, so "L contains an even number of ones" is true.

IH: For all possible legal inputs L, (evenOnes L)=M where M is equivalent to the proposition
stating "L contains an even number of ones".

Leap: With assimption of IH, it holds for (
(x!=1, E is a list with an even number of ones and D is a list with an odd number of ones)
1) (cons 1 E): By IH, (evenOnes E)=#t, (evenOnes (cons 1 E))=(xor #t #t)=#f, which is consistent with IH being true.
2) (cons x E): By IH, (evenOnes E)=#t, (evenOnes (cons x E))=(xor #f #t)=#t, which is consistent with IH being true.
3) (cons 1 D): By IH, (evenOnes D)=#f, (evenOnes (cons 1 D))=(xor #t #f)=#t, which is consistent with IH being true.
4) (cons x D): By IH, (evenOnes D)=#f, (evenOnes (cons x D))=(xor #f #f)=#f, which is consistent with IH being true.

All four cases validate the correctness of the function evenOnes. Therefore, by structural induction,
the function satisfies the stated properties, proving its correctness.

|#

; Question 4: (5 Points)
; Write a recursive function satisifying the following specifications
; Input contract:  L a list (possibly empty)
; Output contract: (duplicate L) is a new list with two copies of each value consecutively in L
(define (duplicate L)
  (if (null? L) null (cons (first L) (cons (first L) (duplicate (rest L))))));Implement Me


(display "Question 4 duplicate Tests\n")
(define-test-suite test_duplicate
  (test-equal? "" (duplicate '(1)) '(1 1))
  (test-equal? "" (duplicate '(null)) '(null null))
  (test-equal? "" (duplicate '(4 6)) '(4 4 6 6))
  (test-equal? "" (duplicate '((1) (2 3))) '((1) (1) (2 3) (2 3)))
  (test-equal? "" (duplicate '(1 4 5 6 4 3 4 5)) '(1 1 4 4 5 5 6 6 4 4 3 3 4 4 5 5)))
(define q4a_score (- 5 (run-tests test_duplicate 'verbose)))

#|
Question 4b (5 Points)
denote (length L) = n
Prove that (length (duplicate L)) = 2*n
You may use the following properties of length, as long as you properly cite them in your proof
Length Property 1: (length null) = 0 
Length Property 2: If a is any object and B is a list
(length (cons a B)) = (+ 1 (length B))
You may Justify lines by saying "by Length Property 1" or "by Length Property 2"
Enter your proof below:

Base case:
LHS:
1. (length (duplicate null))           Premise
2. (length (if (null? null) null (cons (first null) (cons (first null) (duplicate (rest null)))))) Apply def. of duplicate
3. (length (if #t null (cons (first null) (cons (first null) (duplicate (rest null)))))) Evaluate null?
4. (length null)                       Evaluate if
5. 0                                   By length property 1

RHS: 2*0=0
So for the base case, it exists that (length (duplicate L))=2*n

IH: Assume for a list L of length n, (length (duplicate L))=2*n

Leap: With assumption of IH, it holds for (length (duplicate (cons a L))) = 2(n+1)
LHS:
1. (length (duplicate (cons a L)))             Premise
2. (length (if (null? (cons a L)) null (cons (first (cons a L)) (cons (first (cons a L)) (duplicate (rest (cons a L))))))) Apply def. of duplicate
3. (length (if #f null (cons (first (cons a L)) (cons (first (cons a L)) (duplicate (rest (cons a L))))))) Evaluate null?
4. (length (cons (first (cons a L)) (cons (first (cons a L)) (duplicate (rest (cons a L))))) Evaluate if
5. (length (cons a (cons a (duplicate (rest (cons a L)))))  Evaluate first-cons
6. (length (cons a (cons a (duplicate L))))    Evaluate rest-cons
7. (+ 1 (length (cons a (duplicate L))))       By length property 2
8. (+ 1 (+ 1 (length (duplicate L)))           By length property 2
9. (+ 1 (+ 1 (2n)))                            By IH
10. 2(n+1)                                     Algebra

RHS: 2*(n+1)
Since LHS=RHS, we know the theorem is true.

Consequently, since we demonstrated both the base case and the leap step, then
by the principle of racket induction the theorem holds for all inputs for (length (duplicate L))=2*n

|#

; Question 5: (5pts)
; Write a recursive function satisifying the following specifications
; Input contract:  L is a non-empty list
; Output contract: (dropend L) is the same as L but with last element removed
(define (dropend L)
  (if (null? (rest L)) null (cons (first L) (dropend (rest L))))); Implement Me


(display "Question 5 dropend Tests\n")
(define-test-suite test_cut_end
  (test-equal? "" (dropend '(1)) '())
  (test-equal? "" (dropend '(1 2)) '(1))
  (test-equal? "" (dropend '(3 4 (5))) '(3 4))
  (test-equal? "" (dropend '( (1) (2) (3) )) '( (1) (2) ))
  (test-equal? "" (dropend '((1 2 3 4))) '())
  (test-equal? "" (dropend '((1 2) (3 4))) '((1 2)))
  (test-equal? "" (dropend '(9 9 8)) '(9 9))
  (test-equal? "" (dropend '(/ 10 5)) '(/ 10))
  (test-equal? "" (dropend '(OR A B)) '(OR A))
  (test-equal? "" (dropend '(NOT X)) '(NOT)))
(define q5a_score (- 10 (run-tests test_cut_end 'verbose)))

#|
;Question 5b (5 pts)
;denote (length L) = n
;Prove by Induction that (length (dropend L)) = n-1
;You may use the properties of length from Question 3
Enter your proof below:

Base case: A list L with a single element (n=1)
LHS:
1. (length (dropend L))                    Premise
2. (length (if (null? (rest L)) null (cons (first L) (dropend (rest L))))) Apply def. of dropend
3. (length (if #t null (cons (first L) (dropend (rest L))))) Evaluate null?
4. (length null)                           Evaluate if
5. 0                                       By length property 1

RHS: 1-1=0
So for the base case, it exists that (length (dropend L)) = n-1

IH: Assume for a list L of length n, (length (dropend L)) = n-1

Leap: Assume that the IH holds for L with length n, it holds for (length (dropend (cons a L))) = n
LHS:
1. (length (dropend (cons a L)))             Premise
2. (length (if (null? (rest (cons a L))) null (cons (first (cons a L)) (dropend (rest (cons a L))))) Apply def. of dropend
3. (length (if #f null (cons (first (cons a L)) (dropend (rest (cons a L))))) Evaluate null?
4. (length (cons (first (cons a L)) (dropend (rest (cons a L)))) Evaluate if
5. (length (cons (first (cons a L)) (dropend L)))  Evaluate rest-cons
6. (+ 1 (length (dropend L)))                By length property 2
7. 1+(n-1)                                   By IH
8. n                                         Albebra

RHS: The length of list (cons a L) should be n-1+1=n
Since LHS=RHS, we know the theorem is true.

Consequently, since we demonstrated both the base case and the leap step, then
by the principle of racket induction the theorem holds for all inputs for (length (dropend L)) = n-1



|#

; Question 6: (5pts)
; Write a recursive function satisifying the following specifications
; Input contract:  L is a list with even length
; Output contract: (multpairs L) is new list with pairs of elements multiplied together.
; Example:  (multpairs '(2 5 3 1)) would return '(10 3) since 2*5=10 and 3*1=3

(define (multpairs L)
  (if (null? L) null (cons (* (first L) (second L)) (multpairs (rest (rest L)))))); Implement Me


(display "Question 6 add_pairs Tests\n")
(define-test-suite test_multpairs
  (test-equal? "" (multpairs '()) '())
  (test-equal? "" (multpairs '(1 2)) '(2))
  (test-equal? "" (multpairs '(1 2 3 4)) '(2 12))
  (test-equal? "" (multpairs '(2 2 2 2)) '(4 4))
  (test-equal? "" (multpairs '(0 -1 -2 3)) '(0 -6))
  (test-equal? "" (multpairs '(1 1 1 1)) '(1 1))
  (test-equal? "" (multpairs '(1 2 3 4 5 6 7 8)) '(2 12 30 56))
  (test-equal? "" (multpairs '(9 9 9 9 9 9)) '(81 81 81))
  (test-equal? "" (multpairs '(7 3 4 6 5 5)) '(21 24 25))
  (test-equal? "" (multpairs '(-9 9 -8 8)) '(-81 -64)))
(define q6a_score (- 10 (run-tests test_multpairs 'verbose)))

#|
Question 6b (5 pts)
denote (length L) = n
Prove by Induction that (length (multpairs L)) = n/2
You may use the properties of length from Question 4
Enter your proof below:

Base case: Anchored at n = 0
LHS:
1. (length (multpairs null))          Premise
2. (length (if (null? null) null (cons (* (first null) (second null)) (multpairs (rest (rest null))))))  Apply def. of multpairs
3. (length (if #t null (cons (* (first null) (second null)) (multpairs (rest (rest null)))))) Evaluate null?
4. (length null)                      Evaluate if
5. 0                                  By length property 1

RHS: 0/2=0

IH: Assume for a list L of length n, (length (multpairs L)) = n/2

Leap: Assume that the IH holds for L with length n, it holds for
 (length (multpairs (cons a (cons b L))) = (n+2)/2
LHS:
1. (length (multpairs (cons a (cons b L)))         Premise
2. (length (if (null? (cons a (cons b L))) null (cons (* (first (cons a (cons b L))) (second (cons a (cons b L)))) (multpairs (rest (rest (cons a (cons b L)))))))) Apply def. of multpairs
3. (length (if #f null (cons (* (first (cons a (cons b L))) (second (cons a (cons b L)))) (multpairs (rest (rest (cons a (cons b L)))))))) Evaluate null?
4. (length (cons (* (first (cons a (cons b L))) (second (cons a (cons b L)))) (multpairs (rest (rest (cons a (cons b L))))))) Evaluate if
5. (+ 1 (length (multipairs (rest (rest (cons a L)))))))  By length property 2
6. (+ 1 (n/2))                                     By IH
7. (n+2)/2                                         Albegra

RHS: (n+2)/2
Since LHS=RHS, we know the theorem is true.

Consequently, since we demonstrated both the base case and the leap step, then
by the principle of racket induction the theorem holds for all inputs for (length (multpairs L)) = n/2


Question7: the stamp line
Part1A asks you to implement a function, and Part1B asks you to use induction to prove
a property about it.  You are permitted to create helper functions if you wish, and you may
also write lemmas to help with your proof.

Imagine a line of people waiting to get into a nightclub. Each time unit, the bouncers come
around and simultaneously stamp everyone's hand that is waiting on the line and also put a
new unstamped person in front of the person that was just stamped - the stamped person does
not mind, since they're guaranteed entry.  At time unit 0, a single unstamped person begins
the line.  

The goal for 7A is to write code that describes the stampline at any given time.
We shall do this by using the digit 0 to represent an unstamped person, and the digit 1 to
be a person that has the handstamp. We shall create a new list of 0s and 1s out of the old
list of 0s and 1s of the previous time unit by applying the following rewrite rules:

(i) where the old list had a 0, the new list will have a 1. This emulates an unstamped
person getting their hand stamped.
(ii) where the old list had a 1, the new list will have a 0 followed by a 1.  This represents
the stamped person staying the same (i.e. they keep their stamp), but with a new unstamped
person now in front of them.

We shall begin my making the 0th list simply be '(0) -- since this is initializing the line
with a single unstamped individual.
This means the next list will be '(1) by following rule-i
This means that after that one, the new list #2 will be '(0 1) by following rule-ii
List #3 would be (1 0 1).  The leftmost 1 in list#3 came from the 0 in list#2, and then the
0 1 after it comes from the 1 in list#2
Further examples can be seen in the unit tests. |#

; Implement the function stampLine according to the following specifications
; input contract: n is a nonnegative integer (representing the time)
; output contract: (stampLine n) is the nth list as generated from the rewrite rules described above.
; Example: (stampLine 4) would be the list (0 1 1 0 1), since the 101 from list#3 would
; turn into 1->01, 0->1, 1->01

;Question 7A [10 points]: implementing stampLine
(define (stampLine n)
  (if (zero? n)
      '(0)
      (transform (stampLine (- n 1))))); put your code here

(define (transform lst)
  (if (null? lst)
      '()
      (cond
        [(equal? (first lst) 0) (cons 1 (transform (rest lst)))]
        [(equal? (first lst) 1) (cons 0 (cons 1 (transform (rest lst))))])))

#|
 Question 7B [10 points]: Proof
 With #7 complete, you shall now prove the following property of the stampLine function:
 for all n>=2, (stampLine n) = (append (stampLine (- n 2)) (stampLine (- n 1)))
 Example at n=4:  if you attach list#2, 01, to list#3 101, you get 01101 which is list#4
 note that you can NOT use this append property in your Question1 code since that creates
 a circular argument -- we haven't yet proven that append process always comes out to be the
 same as the rewrite rule.  Enter your proof in this empty space of the comment block.
 Recommendation: the proofs go a lot quicker if you first establish lemmas about the values of
 (stampLine 0) and (stampLine 1)

Lemma 1: (stampLine 0) = '(0)
Lemma 2: (stampLine 1) = '(1)

Base case: anchored at n=2
LHS:
1. (stampLine 2)                                           Premise
2. (if (zero? 2) '(0) (transform (stampLine (- 2 1))))     Apply def. of stampLine
3. (if #f '(0) (transform (stampLine (- 2 1))))            Evaluate zero?
4. (transform (stampLine 1))                               Evaluate if and -
5. (transform '(1))                                        By lemma 2
6. (if (null? '(1))
      '()
      (cond
        [(equal? (first '(1)) 0) (cons 1 (transform (rest '(1))))]
        [(equal? (first '(1)) 1) (cons 0 (cons 1 (transform (rest '(1)))))]))  Apply def. of transform
7. (if #f
      '()
      (cond
        [(equal? (first '(1)) 0) (cons 1 (transform (rest '(1))))]
        [(equal? (first '(1)) 1) (cons 0 (cons 1 (transform (rest '(1)))))]))  Evaluate null?
8. (cond
        [(equal? (first '(1)) 0) (cons 1 (transform (rest '(1))))]
        [(equal? (first '(1)) 1) (cons 0 (cons 1 (transform (rest '(1)))))])   Evaluate if
9.(cond
        [#f (cons 1 (transform (rest '(1))))]
        [#t (cons 0 (cons 1 (transform (rest '(1)))))])    Evaluate equal?
10. (cons 0 (cons 1 (transform (rest '(1)))))              Evaluate cond
11. (cons 0 (cons 1 (transform null)))                     Evaluate rest
12. (cons 0 (cons 1 '()))                                  Evaluate null? and if in transform
13. '(0 1)

RHS:
1. (append (stampLine (- 2 2)) (stampLine (- 2 1)))        Premise
2. (append (stampLine 0) (stampLine 1))                    Evaluate -
3. (append '(0) '(1))                                      By lemma 1, 2
4. '(0 1)                                                  Evaluate append

Since LHS=RHS, the base case is true.

IH: Assume for all k>=2, (stampLine k) = (append (stampLine (- k 2)) (stampLine (- k 1)))

Leap: Assume that the IH holds for L with length k, it holds for
      (stampLine (+ k 1)) = (append (stampLine (- (+ k 1) 2)) (stampLine (- (+ k 1) 1)))

LHS:
1. (stampLine (+ k 1))                           Premise
2. (if (zero? (+ k 1))
      '(0)
      (transform (stampLine (- (+ k 1) 1)))))    Apply def. of stampLine
3. (transform (stampLine (- (+ k 1) 1))))        Evaluate +, zero? and if
4. (transform (stampLine k))                     Evaluate + and -
5. (if (null? (stampLine k))
      '()
      (cond
        [(equal? (first (stampLine k)) 0) (cons 1 (transform (rest (stampLine k))))]
        [(equal? (first (stampLine k)) 1) (cons 0 (cons 1 (transform (rest (stampLine k)))))])) Apply def. of transform
6. (cond
        [(equal? (first (stampLine k)) 0) (cons 1 (transform (rest (stampLine k))))]
        [(equal? (first (stampLine k)) 1) (cons 0 (cons 1 (transform (rest (stampLine k)))))]) Evaluate null? and if
(D is a list starts with 0 and E is a list starts with 1)
1) if (stampLine k)=D
(cons 1 (transform (rest (stampLine k)))
2) if (stampLine k)=E
7. (cons 0 (cons 1 (transform (rest (stampLine k))))    Evalulate cond
8. (cons 0 (cons 1 (transform (rest (append (stampLine (- k 2)) (stampLine (- k 1)))) By IH
9. (append (transform (stampLine (- k 2)) (transform (stampLine(- k 1)))))   Apply def. of transform
10. (append (stampLine (- k 1)) (stampLine(k)))      Apply def. of transform

RHS:
1. (append (stampLine (- (+ k 1) 2)) (stampLine (- (+ k 1) 1))) Premise
2. (append (stampLine (- k 1)) (stampLine(k)))    Evaluate + and -

Since LHS=RHS, we know the theorem is true.

Consequently, since we demonstrated both the base case and the leap step, then
by the principle of racket induction the theorem holds for all inputs
for all k>=2, (stampLine k) = (append (stampLine (- k 2)) (stampLine (- k 1)))




Question 8: Triads
There is nothing for you to implement for this question; all the code you need is provided.
A "mix" of a 3 element list is defined as replacing each member by the sum of the other two
and then adding 3 to the middle number and adding 2 to the ends.
For example, doing a "mix" of the list (10 20 30) would give us (52 43 32) since 20+30+2=52
(the 20&30 are the other values that weren't in the 10 position), and similarly the rest are
10+30+3=43, and 10+20+2=32.  This concept is implemented in the functions below  |#
(define/contract (mix a b c)
  (-> integer? integer? integer? list?)
  (cons (+ b c 2) (cons (+ a c 3) (cons (+ a b 2) null))))

; Recommendation: these proofs go much smoother if you establish lemmas about the
; first/second/third of (mix a b c)

; unmix is an inverse of sorts to mix. Note: you do NOT need to directly use this function
; in your proofs.  It is only here to make it easier to implement a certain predicate (below).
; To see the idea of how it works, since (mix 10 20 30) gives (52 43 32),
; if we do (unmix 52 43 32) it will give back (10 20 30)
(define/contract (unmix a b c)
  (-> integer? integer? integer? list?)
  (list (- (quotient (+ a b c -7) 2) a -2) (- (quotient (+ a b c -7) 2) b -3)
        (- (quotient (+ a b c -7) 2) c -2)))
#|
A Triad is a list of three positive integers with the following recursively defined property.
Triad := (8 4 9) | (13 14 15) | (mix Triad)
In plain English, (8 4 9) and (13 14 15) are automatically considered triads, and the mix of
a triad stays a triad. As an example, we can see that (62 63 64) is a triad. The reasoning is
that we know that (13 14 15) is a triad, thus when we mix it to get (31 31 29) that will be a
triad too. And if we mix that new triad, we arrive at the desired triad (62 63 64).
Observe that once the numbers get big, it's not obvious whether a triple is a valid Triad or
not -- e.g. is (294 295 300) a Triad? It turns out the answer is no, but (295 300 294) is.
It's clear that it may be helpful to have code available to quickly determine this for us.
The function provided below implements a predicate checking for Triads:
|#
(define (triad? L)
  (if (not (and (list? L) (equal? (length L) 3)
               (positive? (first L)) (positive? (second L)) (positive? (third L)))) #f
   (or (equal? L '(8 4 9)) (equal? L '(13 14 15))
          (triad? (unmix (first L) (second L) (third L))))))
          ; this last line is checking if L came from the mix of a Triad
#|
Prove or Disprove the following conjectures about any list L=(a b c) of positive integers.
Note: if you think it is true, then you must give a proof by structural induction
(note that your proof will be a combination of Equational Reasoning with racket, wrapped in
some English explanation of the induction template).

If you think it is false, then you must provide a counterexample. Note that if you claim a
specific list is or isn't a Triad, then you must actually PROVE it. Using the Racket
predicate to do so is NOT sufficient, unless you prove its correctness). To prove a list is
a Triad, you simply have to show it follows the mathematical (NOT racket) definition.
To prove a list is NOT a Triad, the best way is to use induction to prove a property that
all Triads have that your list does not have (like the OPOPOPO example from lecture).

In your proof(s) of the parts of Question8 you may use the following theorems for free:

The Commutative Property:
(+ x y) is (+ y x)
[roughly in plain English: "you can shift around the order of inputs in an addition without
changing the answer". and you can do this with any number of inputs in the sum]

The Associative Property:
(+ x (+ y z)) is (+ (+ x y) z)
[roughly in plain English: "you can shift parentheses around in an addition".
and you can do this with any number of inputs in the sum]

The Remainder Property:
(remainder (+ X Y) m) is (remainder (+ (remainder X m) (remainder Y m) m)
[roughly in plain English: "the sum of remainders is the remainder of the sum"
and you can do this with any number of inputs in the sum]


Part8A [10pts]: If L is a triad then (remainder(+(first L)(first(rest L))(first(rest(rest L)))) 7)=0
[in plain English: "the values of a Triad always sum to a multiple of 7"]
note that in future courses, the proofs may be formal and stated 100% in code, like this:
(implies (triad? L) (zero? (remainder (+ (first L)(first(rest L))(first(rest(rest L)))) 7))
But we're not going to do that in cs270

Base case: A list L with exactly three elements (8, 4, 9)
LHS:
1. (remainder (+ (first L) (first (rest L)) (first (rest (rest L))))7) Premise
2. (remainder (+ 8 4 9) 7)                 Evaluate first and rest
3. (remainder (21) 7)                      Apply def. of Triad
4. 0                                       Apply def. of remainder

RHS: 0 Since L is a Triad, a+b+c is a multiple of 7
Since LHS=RHS, the base case (remainder (+ (first L) (first (rest L)) (first (rest (rest L))))7)=0 holds true

IH: Assume for a list L of three elements (a,b,c) that is a triad, (remainder (+ a b c) 7)=0.
 
1. (remainder (+ (+ b c 2) (+ a c 3) (+ a b 2)) 7)             Premise
2. (remainder (+ (+ a b c) (+ a b c) 7)                        By commutative and associative property
3. (remainder (+ (remainder (+ a b c) 7) (remainder (+ a b c) 7)) 7) By remainder property
4. (remainder 0 7)                                             By IH
5. 0

Since we demonstrated that the base case holds, then by the principle of structural induction,
the theorem holds for all Triads L, (remainder(+(first L)(first(rest L))(first(rest(rest L)))) 7)=0


Part8B [10pts]: If (remainder(+(first L)(first(rest L))(first(rest(rest L)))) 7)=0, then L is a triad.
[in plain English: "if three numbers sum to a multiple of 7, then they form a Triad"]

Proposed property: For any Triad L = (a, b, c), a+b+c>20

Base case:
1. 8+4+9=21>20
2. 13+14+15=42>20

IH: Assume for some Triad L=(a, b, c) the property holds.

Leap: for the mix of L, mix(a, b, c) also satisfies the property

Calculating the sum of the elements of the mix:
(+ (+ b c 2) (+ a c 3) (+ a b 2)) = 2(a+b+c)+7

By IH we have a+b+c>20
so that 2(a+b+c)+7>2*20+7=47
By structural induction, we've proven that for any Triad, the sum a+b+c is always greater than 20.

Counterexample:

L=(1, 2, 4) satifies (remainder L 7)=0, however it does not fit the proposed property that proven
all Triad must have, so it is not a Traid.

|#
(display "Question 7 stampLine: 10 tests\n")
(define-test-suite test_stampLine
  (test-equal? "" (stampLine 0) '(0))
  (test-equal? "" (stampLine 1) '(1))
  (test-equal? "" (stampLine 2) '(0 1))
  (test-equal? "" (stampLine 3) '(1 0 1))
  (test-equal? "" (stampLine 4) '(0 1 1 0 1))
  (test-equal? "" (stampLine 5) '(1 0 1 0 1 1 0 1))
  (test-equal? "" (stampLine 6) '(0 1 1 0 1 1 0 1 0 1 1 0 1))
  (test-equal? "" (stampLine 7) '(1 0 1 0 1 1 0 1 0 1 1 0 1 1 0 1 0 1 1 0 1))
  (test-equal? "" (stampLine 8) '(0 1 1 0 1 1 0 1 0 1 1 0 1 1 0 1 0 1 1 0 1 0 1 1 0 1 1 0 1 0 1 1 0 1))
  (test-equal? "" (stampLine 9) '(1 0 1 0 1 1 0 1 0 1 1 0 1 1 0 1 0 1 1 0 1 0 1 1 0 1 1 0 1 0 1 1 0 1 1 0 1 0 1 1 0 1 0 1 1 0 1 1 0 1 0 1 1 0 1)))
(define q7a_score (- 10 (run-tests test_stampLine 'verbose)))

(display "------Unit Test Summary------\n")
(display "Q1 Passed ")
(display q1b_score)
(display "/12\n")
(display "Q2 Passed ")
(display q2a_score)
(display "/5\n")
(display "Q3 Passed ")
(display q3a_score)
(display "/10\n")
(display "Q4 Passed ")
(display q4a_score)
(display "/5\n")
(display "Q5 Passed ")
(display q5a_score)
(display "/10\n")
(display "Q6 Passed ")
(display q6a_score)
(display "/10\n")
(display "Q7A Passed ")
(display q7a_score)
(display "/10\n")